## Overview

This directory contains the core functionalities of the **Java Compiler**. Written with `flex`( lexical scanner ) and `bison` ( syntax analyzer ). Look at the next section If you want to compile from source ( if you want to run the compiler without the UI )

## Technical Overview

The Compiler is divided into 3 parts: `lexical scanner`, `syntax parser` and `semantic parser`

### Lexical Scanner

Lexical analysis is used to **detect the diffferent tokens** that belong to our grammar. These token are later passed on to the Syntax analysis. These compiler can detect **most** of the java basic tokens. Check [java_lexer.yy](./java_lexer.yy) which describes this process in details.

Lexical analysis is done using `flex` and `c++`. `c++` files will be generated by the scanner which makes it more flexible to use in the syntax parser later on ( more flexible that the standard `c` generated files )

#### Error Handling

A few lexical errors are handled by this Compiler: 

- `Invalid Identifer` : Any identifer starting by a number.
- `unclosed comments` : multi line comments that weren't properly closed.
- `invalid symbol` : any symbol that doesn't belong to the list of described tokens.

### Syntax Parser

Syntax analysis is used to **check that tokens conform to the described grammar**. the grammar used is a minified version of the Java Grammar. The parser used  is an **LALR** parser. 

The Syntax parser is written entirely in `bison`  and `c++`. File generated by the parser will also be `c++` files. This ensures more flexibility later on ( to communicate with the semantic parser ).

The grammar ( described in [java_parser.yy](./java_parser.yy) ) supports associative rules and the order of priority. It also supports most of the basic java statements. 

Locations are used to detect the exact position of each token ( used mainly to show more detailed error messages).

Error handling is passed on to the `Driver` which works as a **glue** between the different components of the compiler. See the section about the Driver below. Any token not conforming to the grammar will generated an errors in the format of: `syntax error, unexpected token '' expecting '' or '' or ...`

### Semantic Parser

Semantic analysis is used to **detect the different semantic errors** that might arise. It's written in `c++` and uses many data structures

#### Structure

- each scope is described by a `scope` structure. which contains a `hashmap` where the **keys** are the `identifiers` and the **values** are the different properties of the `identifier`.

- The `symbol table` is a `list` of `scope`. Each time we enter a new `scope` ( by using an `{` ) we add a new entry to this list. Once we exit the scope ( by using an `}` ) we remove the last entry from this list. It basically plays the role of a `stack`. For more information check [java_semantics.cc](./java_semantics.cc) and [java_semantics.hh](./java_semantics.hh)

#### Error handling

For now, the current semantic errors are handled:

- identifier not declared
- identifier already declared
- identifier used not initialized 
- identifier declared but its values is never used
- invalid number of args for a function fall
- calling a function that doesn't exist

### Gluing comoponents together: the Driver

the Driver is used to link the lexical scanner, the syntax parser and the semantic parser. Errors generated by the syntax parser are handled here also. To use the compiler we should use this class. For more information check [driver.hh](./driver.hh) and [driver.cc](./driver.cc)

## Usage (as a standalone application)

### Compiling sources

You can use one of the two methods listed below. Note that both will generate a `javacompiler` binary. That's your entry point to the application

Note that you'll only have access to the core compiler ( No GUI ). If you want to use the GUI run the entire project ( through `CMakeLists.txt` )

#### Using the makefile

To compile everything, run :

```bash
make
```

To clean object files, run : 

```bash
make clean
```


to clean generated files (by flex/bison) in addition to object files, run :

```bash
make cleanall
```

#### Using the script

You can also compile the project by running the script :

```bash
./analyze++
```

### Running the compiler

To run the compiler, simply run the generated binary while providing the **java file** on input

```bash
./javacompiler Test.java
```

Or You can also pipe the input

```bash
./javacompiler < Test.java # cat Test.java | ./javacompiler
```

> **Note:** No output will be given if no errors have been detected. Add errors to your source file and check the generated errors. 